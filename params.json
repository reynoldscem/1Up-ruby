{"name":"1up-ruby","tagline":"","body":"Welcome\r\n=======\r\n\r\nHello and welcome to 1-UP's Ruby workshop. Whether you're entirely new to programming, new to the Ruby language or just want to learn something new - we hope that you will get something of benefit. \r\n\r\nYou can work alone, or in pairs. Pair programming is a very good technique that is used alot in Agile teams. While it may seem like you'd get less work done with two programmers per computer, just think how much of your programming time are you spending actually typing and how much are you spending *thinking*.\r\n\r\nSolutions and random snippets are available by the links above / GitHub. Among these are the solutions to the tasks. It would be possible to read them and to 'cheat', but this would probably just hurt your own learning. \r\n\r\nYou can see how to install Ruby on you operating system of choice [here](https://www.ruby-lang.org/en/installation/).\r\n\r\nBasic syntax\r\n============\r\n\r\nFirst off let's take a look at some basic methods in Ruby. `puts()` is used to print text to the screen. Try typing this in into a file called `anything.rb` and running it with `ruby anything.rb`.\r\n\r\n```ruby\r\nputs(\"Hello World!\")\r\nputs \"Hello world!\"\r\n```\r\n\r\nWe can see that \"Hello World!\" is printed twice, even though the second time the brackets were missing! In Ruby methods which take only one argument don't need brackets - this might seem weird if you're coming from other languages, but similar things happen in many languages it is often just that we don't think about what is happening behind the scenes.\r\n\r\n```ruby\r\n# Print out some arithmetic\r\nputs 1+2\r\nputs 1.+(2)\r\n```\r\n\r\nThese two lines do exactly the same thing. As it turns out the operators we use all the time are just methods like anything else and can be called with that standard `thing1.method(argument)` syntax. The process of making an easier to read form of elements of a programming language is called *sugar*. Ruby is a very sugary language - I'd argue this makes it pretty sweet to write ;)\r\n\r\nLet's try and make this a little more personal by printing out your own name - we can either get this from standard input or from command line arguments. In order to make this workshop a little less of a walkthrough, I'm going to try to avoid just giving you code to run and instead give you the building blocks and let you come up with a solution, this is to make it less tedious for those with some (or lots!) of programming experience. If you are new, and find yourself getting stuck be sure to ask for help!\r\n\r\nRead the following snippet, and see if you can print out a greeting to yourself, giving your name from standard input in just one line.\r\n\r\n```ruby \r\nsomeInput = gets.chomp\r\n# gets is used to get a line of input from standard in\r\n# chomp is used to 'eat up' newline characters off of strings\r\n\r\nstring1 = \"Ruby\"\r\nstring2 = \"open source\"\r\n\r\nputs \"#{string1} is completely #{strings2}\"\r\n# #{variable} is used to interpolate (include) variables in a string.\r\n# If you're used to other languages (Python, Java, C*), Ruby also supports interpolation in their style.\r\nputs \"%s is completely %s\" % [string1, string2]\r\n```\r\n\r\nAssuming you've got a solution for that (don't worry if it's a few lines) let's compare that to the same thing in Java.\r\n\r\n```java\r\nimport java.io.*;\r\npublic class example\r\n{\r\n  public static void main (String[] args)\r\n  {\r\n    try\r\n    {\r\n      BufferedReader stdin = new BufferedReader(new InputStreamReader(System.in));\r\n      String name;\r\n      name = stdin.readLine();\r\n      System.out.println(\"Hello \" + name);\r\n    } catch (IOException e) {\r\n      System.err.println(\"IOException: \" + e.getMessage());\r\n    }\r\n  }\r\n}\r\n\r\n```\r\n\r\nA lot longer and harder to understand right? Maybe this will give an insight into why ruby programmers start preferring it so much over other languages. While this is a tiny example, the extra readability and ease of writing can make a huge difference in big projects!\r\n\r\nCollections\r\n===========\r\n\r\nIn programs we often want to have groups of things, the main ways we represent this is with `arrays` and `hashes`. Hashes are also called maps, dictionaries and hashmaps in other languages.\r\n\r\n```ruby\r\nanimals = [\"dog\", \"cat\", \"hamster\"]\r\nputs animals\r\n\r\npeople = [\"charlie\", \"mark\", \"dave\"]\r\nputs people[0]\r\nputs people.first\r\nputs people\r\n\r\nnumbers = [78, 0, 47.8, -100, 1/0.0, Math::PI]\r\nputs numbers\r\nputs numbers.first\r\nputs numbers.max\r\n# Arrays come with some useful methods\r\n\r\nmixed = [78, nil, \"charlie\"]\r\nputs mixed\r\n# We can easily mix types in arrays (as everything is an object)\r\n\r\npetHash = {\"charlie\" => \"dog\", \"mark\" => \"cat\", \"dave\" => \"hamster\"}\r\nputs petHash.keys\r\nputs petHash.values\r\nputs petHash[\"charlie\"]\r\nputs petHash[\"dave\"]\r\n\r\npetHash[\"lewis\"] = \"snake\"\r\nputs petHash\r\n```\r\n\r\nIf we wanted to do some simple operations, like put the two arrays `animals` and `people` together to make the hash petHash we normally might think in terms of loops. Going through every element in the arrays and adding them into a hash. In Ruby this is not very idiomatic - in fact it may shock you to learn that Ruby has no `For` construct!\r\n\r\n```ruby\r\npetHash = Hash[people.zip(animals)]\r\n# This is (one of the ways) how we can do the above in Ruby.\r\n```\r\n\r\nControl Flow\r\n============\r\n\r\nTo start simply, Ruby features the standard if, while and case statements. Though with a few little differences.\r\n\r\n```Ruby\r\nif 2.even?                             # methods ending in ? return booleans!\r\n  puts \"Even!\"\r\nelsif 2.zero?\r\n  puts \"Something is wrong...\"\r\nelse\r\n  puts \"Odd?!\"\r\nend\r\n\r\nx = 0\r\nwhile x < 10\r\n  x = x + 1\r\nend\r\n\r\nprint \"Enter your favourite color: \"\r\n\r\ncase gets.chomp.downcase\r\nwhen \"red\"\r\n  puts \"Red as Rubies!\"\r\nwhen \"green\"\r\n  puts \"Green as grass!\"\r\nwhen \"blue\"\r\n  puts \"Blue as the sky!\"\r\nelse                                    # default case\r\n  puts \"I only like primary colours...\"\r\nend\r\n```\r\nAll pretty standard stuff, you may notice the statements terminate in `end` - this is to delimit the statements and is simply intrinsic to the syntax. I personally find it preferable to the Python scheme of using whitespace for this. The `case` and `when` being at the same level of indentation is purely stylistic - but this style is the preferred one. Now for how these constructs differ in little in Ruby!\r\n\r\n```Ruby\r\nputs \"Statements work inline!\" if 2.even?\r\n\r\nputs x = x + 1 while x < 10\r\n\r\n# Opposite of while\r\nuntil x.zero?\r\n  puts x = x - 1\r\nend\r\n\r\n# Opposite of if\r\nunless 2.odd?\r\n  puts \"Even!\"\r\nend\r\n```\r\n\r\nSometimes these can get confusing, sometimes they can make code more readable or concise. When you use them is up to you.\r\n\r\nWhere's my For loop?!?\r\n======================\r\n\r\nBefore I mentioned that Ruby has no `For` loop. This might seem very bizarre, but many of you will already be familiar with the styles of iteration that are utilised in Ruby (though perhaps not how they are implemented). Ruby extensively uses enumerables - these are objects which move successively through states. They can be used in multiple ways, and we can even define our own though for now we will just look at basic ones.\r\n\r\n```Ruby\r\n10.times # Not very useful at the moment...\r\n\r\n10.times { puts \"Loops!\" }\r\n```\r\n\r\n`do end`, and `{ }` are (very nearly) exactly the same thing. `{ }` is preferred for single line use, and `do end` for multi. They are called blocks and though they may seem simple, they are one of Ruby's most powerful assets. They are NOT the same as compound statements in C-like languages.\r\n\r\n```Ruby\r\n1..100   # A range from 1-100, a type of collection\r\n1...100  # A range from 1-99\r\n\r\n(1..10).each {|x| puts x*x*x} # Print the cube of all numbers from 1-10\r\n```\r\neach takes a collection, such as a range, an array or a hash and passes each item in the collection successively to the block. How to refer to the items passed from the collection is specified between the pipes `| |`. Let's see something using a few of the things we've seen so far.\r\n\r\n```Ruby\r\nanimals = [\"dog\", \"cat\", \"hamster\"]\r\npeople = [\"charlie\", \"mark\", \"dave\"]\r\npetHash = Hash[people.zip(animals)]\r\n\r\n(petHash).each do |person, pet| \r\n  puts \"#{person.capitalize} loves their #{pet}\"\r\nend\r\n```\r\n\r\nTime for task 1\r\n===============\r\n\r\nThe program Greetings should take a list of names passed as command line arguments like this: `ruby greetings.rb charlie lewis nathan`\r\n\r\nIt should print out:\r\nHello Charlie!\r\nHello Lewis!\r\nHello Nathan!\r\n\r\nYou will need:\r\n```Ruby\r\nARGV         # The array containing all your command line arguments.\r\n```\r\n\r\nTask 2\r\n======\r\n\r\nThe program FizzBuzz should take as an argument an integer to be passed via the command line like this: `ruby fizzbuzz.rb 20`\r\n\r\nIt should print out Fizz if the number is divisible by 3, Buzz if it is divisible by 5, FizzBuzz if it is divisible by 15 and the number itself if it is divisible by neither 3 nor 5. This should be doable with what we've seen already, plus a couple of things I'll demonstrate below. Feel free to try to write this in pairs.\r\n\r\n```Ruby\r\nx.modulo(y)  # The remainder of dividing x by y\r\n\"3\".to_i     # String to integer\r\n```","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}